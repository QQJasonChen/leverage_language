// Ê≠∑Âè≤Ë®òÈåÑÁÆ°ÁêÜÊ®°ÁµÑ
class HistoryManager {
  constructor() {
    this.STORAGE_KEY = 'queryHistory';
    this.MAX_HISTORY_SIZE = 1000;
  }

  // Ê∑ªÂä†Êñ∞ÁöÑÊü•Ë©¢Ë®òÈåÑ
  async addRecord(text, language, detectionMethod = 'auto', websitesUsed = [], videoSource = null) {
    try {
      const record = {
        id: this.generateId(),
        text: text.trim(),
        language: language,
        timestamp: Date.now(),
        detectionMethod: detectionMethod, // 'auto', 'manual', 'preferred'
        websitesUsed: websitesUsed,
        queryCount: 1,
        videoSource: videoSource // { url, title, channel, timestamp }
      };

      const history = await this.getHistory();
      
      // ÈõôÈáç‰øùÈö™ÔºöÁ¢∫‰øù history ÊòØÊï∏ÁµÑ
      if (!Array.isArray(history)) {
        console.error('‚ö†Ô∏è getHistory() did not return an array:', typeof history, history);
        throw new Error('History data is corrupted, cannot add record');
      }
      
      // Ê™¢Êü•ÊòØÂê¶Â∑≤Â≠òÂú®Áõ∏ÂêåÁöÑÊü•Ë©¢
      // For YouTube learning with timestamps, treat each timestamp as a unique entry
      let existingIndex = -1;
      
      if (videoSource && videoSource.videoTimestamp !== null && videoSource.videoTimestamp !== undefined) {
        // For video learning: check text + language + video URL + timestamp
        existingIndex = history.findIndex(item => 
          item.text === record.text && 
          item.language === record.language &&
          item.videoSource?.url === videoSource.url &&
          item.videoSource?.videoTimestamp === videoSource.videoTimestamp
        );
      } else if (detectionMethod === 'article-selection') {
        // For article selections: treat each as unique - don't deduplicate
        // Each article selection should be its own entry even if same text
        existingIndex = -1;
      } else {
        // For regular queries: treat each as a new entry to preserve full history
        // This allows users to see all their search history, not just unique terms
        existingIndex = -1;
      }

      if (existingIndex !== -1) {
        // Êõ¥Êñ∞ÁèæÊúâË®òÈåÑ
        history[existingIndex].timestamp = record.timestamp;
        history[existingIndex].queryCount += 1;
        history[existingIndex].websitesUsed = [...new Set([...history[existingIndex].websitesUsed, ...websitesUsed])];
        
        // Êõ¥Êñ∞ÂΩ±Áâá‰æÜÊ∫êË≥áË®äÔºàÂ¶ÇÊûúÊèê‰æõ‰∫ÜÊñ∞ÁöÑÂΩ±Áâá‰æÜÊ∫êÔºâ
        if (videoSource) {
          if (!history[existingIndex].videoSources) {
            history[existingIndex].videoSources = [];
          }
          // Ê∑ªÂä†Êñ∞ÁöÑÂΩ±Áâá‰æÜÊ∫êÔºåÈÅøÂÖçÈáçË§á
          const existingVideoIndex = history[existingIndex].videoSources.findIndex(v => v.url === videoSource.url);
          if (existingVideoIndex === -1) {
            history[existingIndex].videoSources.push(videoSource);
          } else {
            // Êõ¥Êñ∞ÁèæÊúâÂΩ±ÁâáÁöÑÊôÇÈñìÊà≥
            history[existingIndex].videoSources[existingVideoIndex].timestamp = videoSource.timestamp;
          }
          
          // ‰øùÊåÅÊúÄÊñ∞ÁöÑÂΩ±Áâá‰æÜÊ∫ê‰ΩúÁÇ∫‰∏ªË¶Å‰æÜÊ∫ê
          history[existingIndex].videoSource = videoSource;
        }
      } else {
        // Ê∑ªÂä†Êñ∞Ë®òÈåÑ
        if (videoSource) {
          record.videoSources = [videoSource]; // ÂàùÂßãÂåñÂΩ±Áâá‰æÜÊ∫êÈô£Âàó
        }
        history.unshift(record);
      }

      // ‰øùÊåÅË®òÈåÑÊï∏ÈáèÂú®ÈôêÂà∂ÁØÑÂúçÂÖß
      if (history.length > this.MAX_HISTORY_SIZE) {
        history.splice(this.MAX_HISTORY_SIZE);
      }

      await this.saveHistory(history);
      
      // üéØ DEBUG: Show complete saved record structure for timestamp verification
      console.log('üíæ SAVED RECORD DEBUG - Complete structure:', JSON.stringify(record, null, 2));
      console.log('‚è∞ SAVED RECORD DEBUG - Timestamp details:', {
        hasVideoSource: !!record.videoSource,
        videoTimestamp: record.videoSource?.videoTimestamp,
        timestampType: typeof record.videoSource?.videoTimestamp,
        timestampIsNull: record.videoSource?.videoTimestamp === null,
        timestampIsUndefined: record.videoSource?.videoTimestamp === undefined
      });
      
      return record;
    } catch (error) {
      console.error('Ê∑ªÂä†Ê≠∑Âè≤Ë®òÈåÑÂ§±Êïó:', error);
      throw error;
    }
  }

  // Áç≤ÂèñÊ≠∑Âè≤Ë®òÈåÑ
  async getHistory() {
    try {
      const result = await chrome.storage.local.get([this.STORAGE_KEY]);
      const history = result[this.STORAGE_KEY];
      
      // È©óË≠âÂíå‰øÆÂæ©Êï∏Êìö
      if (!history) {
        console.log('üìù History not found, initializing empty array');
        return [];
      }
      
      if (!Array.isArray(history)) {
        console.error('‚ö†Ô∏è History data is corrupted (not an array):', typeof history);
        console.log('üìä Corrupted data sample:', JSON.stringify(history).substring(0, 200) + '...');
        
        let recoveredItems = [];
        
        // ÂòóË©¶‰øÆÂæ©ÔºöÂ¶ÇÊûúÊòØÂ∞çË±°ÔºåÂòóË©¶Â§öÁ®ÆÊÅ¢Âæ©ÊñπÊ≥ï
        if (typeof history === 'object' && history !== null) {
          console.log('üîß Attempting to recover history from object format...');
          
          // Method 1: Try to extract from Object.values()
          try {
            const entries = Object.values(history);
            console.log(`üìã Found ${entries.length} entries in object values`);
            
            const validEntries = entries.filter(item => {
              return item && 
                     typeof item === 'object' && 
                     typeof item.text === 'string' && 
                     typeof item.language === 'string' &&
                     typeof item.timestamp === 'number';
            });
            
            if (validEntries.length > 0) {
              console.log(`‚úÖ Recovered ${validEntries.length} valid entries from object values`);
              recoveredItems = validEntries;
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Method 1 (Object.values) failed:', error);
          }
          
          // Method 2: If object has array-like properties (0, 1, 2...)
          if (recoveredItems.length === 0) {
            try {
              const keys = Object.keys(history).filter(key => /^\d+$/.test(key));
              if (keys.length > 0) {
                console.log(`üîç Found ${keys.length} numeric keys, attempting array-like recovery`);
                
                const arrayLikeItems = keys.map(key => history[key]).filter(item => {
                  return item && 
                         typeof item === 'object' && 
                         typeof item.text === 'string';
                });
                
                if (arrayLikeItems.length > 0) {
                  console.log(`‚úÖ Recovered ${arrayLikeItems.length} items from array-like object`);
                  recoveredItems = arrayLikeItems;
                }
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è Method 2 (array-like) failed:', error);
            }
          }
          
          // Method 3: Look for nested arrays
          if (recoveredItems.length === 0) {
            try {
              for (const [key, value] of Object.entries(history)) {
                if (Array.isArray(value) && value.length > 0) {
                  console.log(`üîç Found array in key "${key}" with ${value.length} items`);
                  const validItems = value.filter(item => 
                    item && typeof item === 'object' && item.text
                  );
                  if (validItems.length > 0) {
                    console.log(`‚úÖ Recovered ${validItems.length} items from nested array`);
                    recoveredItems = validItems;
                    break;
                  }
                }
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è Method 3 (nested arrays) failed:', error);
            }
          }
        }
        
        // If recovery successful, save and return recovered data
        if (recoveredItems.length > 0) {
          console.log(`üéâ Successfully recovered ${recoveredItems.length} history items!`);
          await this.saveHistory(recoveredItems);
          return recoveredItems;
        }
        
        // ÁÑ°Ê≥ï‰øÆÂæ©ÔºåÈáçÁΩÆÁÇ∫Á©∫Êï∏ÁµÑ
        console.log('üîÑ No recovery possible, resetting corrupted history to empty array');
        await this.clearHistory();
        return [];
      }
      
      // È©óË≠âÊï∏ÁµÑ‰∏≠ÁöÑÈ†ÖÁõÆ
      const validHistory = history.filter(item => {
        if (!item || typeof item !== 'object') {
          console.warn('‚ö†Ô∏è Removing invalid history item:', item);
          return false;
        }
        if (!item.text || !item.language || !item.timestamp) {
          console.warn('‚ö†Ô∏è Removing incomplete history item:', item);
          return false;
        }
        return true;
      });
      
      // Â¶ÇÊûúÈÅéÊøæÂæåÁöÑÊï∏ÊìöËàáÂéüÊï∏Êìö‰∏çÂêåÔºå‰øùÂ≠òÊ∏ÖÁêÜÂæåÁöÑÁâàÊú¨
      if (validHistory.length !== history.length) {
        console.log(`üîß Cleaned history: ${history.length} ‚Üí ${validHistory.length} items`);
        await this.saveHistory(validHistory);
      }
      
      return validHistory;
    } catch (error) {
      console.error('Áç≤ÂèñÊ≠∑Âè≤Ë®òÈåÑÂ§±Êïó:', error);
      return [];
    }
  }

  // ‰øùÂ≠òÊ≠∑Âè≤Ë®òÈåÑ
  async saveHistory(history) {
    try {
      // È©óË≠âËº∏ÂÖ•Êï∏Êìö
      if (!Array.isArray(history)) {
        console.error('‚ö†Ô∏è Attempting to save non-array as history:', typeof history);
        throw new Error('Cannot save non-array data as history');
      }
      
      // Á¢∫‰øùÊâÄÊúâÈ†ÖÁõÆÈÉΩÊòØÊúâÊïàÁöÑÊ≠∑Âè≤Ë®òÈåÑ
      const validHistory = history.filter((item, index) => {
        if (!item || typeof item !== 'object') {
          console.warn(`‚ö†Ô∏è Removing invalid item at index ${index}: not an object`);
          return false;
        }
        
        if (typeof item.text !== 'string' || !item.text.trim()) {
          console.warn(`‚ö†Ô∏è Removing item at index ${index}: invalid text`);
          return false;
        }
        
        if (typeof item.language !== 'string' || !item.language.trim()) {
          console.warn(`‚ö†Ô∏è Removing item at index ${index}: invalid language`);
          return false;
        }
        
        if (typeof item.timestamp !== 'number' || item.timestamp <= 0) {
          console.warn(`‚ö†Ô∏è Removing item at index ${index}: invalid timestamp`);
          return false;
        }
        
        // Ensure required fields exist
        if (!item.id) {
          console.warn(`‚ö†Ô∏è Item at index ${index} missing ID, generating new one`);
          item.id = this.generateId();
        }
        
        if (typeof item.queryCount !== 'number' || item.queryCount <= 0) {
          console.warn(`‚ö†Ô∏è Item at index ${index} has invalid queryCount, setting to 1`);
          item.queryCount = 1;
        }
        
        return true;
      });
      
      if (validHistory.length !== history.length) {
        console.warn(`‚ö†Ô∏è Filtered out ${history.length - validHistory.length} invalid history items`);
      }
      
      // Double-check: make sure we're still saving an array
      if (!Array.isArray(validHistory)) {
        console.error('‚ö†Ô∏è validHistory is not an array after filtering!');
        throw new Error('Data corruption during validation');
      }
      
      // Create backup before saving if this is a significant change
      if (validHistory.length > 0 && history.length - validHistory.length > 5) {
        console.log('üîÑ Creating backup due to significant data changes...');
        await chrome.storage.local.set({
          [`${this.STORAGE_KEY}_backup_${Date.now()}`]: history
        });
      }
      
      await chrome.storage.local.set({
        [this.STORAGE_KEY]: validHistory
      });
      
      console.log(`‚úÖ Saved ${validHistory.length} history records successfully`);
      
      // Verify the save was successful
      const verification = await chrome.storage.local.get([this.STORAGE_KEY]);
      const savedData = verification[this.STORAGE_KEY];
      
      if (!Array.isArray(savedData)) {
        console.error('‚ùå CRITICAL: Data corrupted immediately after save!');
        console.error('Saved data type:', typeof savedData);
        console.error('Saved data:', savedData);
        throw new Error('Data corruption detected immediately after save');
      }
      
      console.log(`üîç Save verification passed: ${savedData.length} items confirmed`);
      
    } catch (error) {
      console.error('‰øùÂ≠òÊ≠∑Âè≤Ë®òÈåÑÂ§±Êïó:', error);
      throw error;
    }
  }

  // ÊêúÂ∞ãÊ≠∑Âè≤Ë®òÈåÑ
  async searchHistory(query, language = null) {
    try {
      const history = await this.getHistory();
      if (!Array.isArray(history)) {
        console.error('‚ö†Ô∏è searchHistory: history is not an array');
        return [];
      }
      
      const lowerQuery = query.toLowerCase();
      
      return history.filter(record => {
        const matchesText = record.text.toLowerCase().includes(lowerQuery);
        const matchesLanguage = !language || record.language === language;
        return matchesText && matchesLanguage;
      });
    } catch (error) {
      console.error('ÊêúÂ∞ãÊ≠∑Âè≤Ë®òÈåÑÂ§±Êïó:', error);
      return [];
    }
  }

  // ÊåâË™ûË®ÄÁç≤ÂèñÊ≠∑Âè≤Ë®òÈåÑ
  async getHistoryByLanguage(language) {
    try {
      const history = await this.getHistory();
      if (!Array.isArray(history)) {
        console.error('‚ö†Ô∏è getHistoryByLanguage: history is not an array');
        return [];
      }
      return history.filter(record => record.language === language);
    } catch (error) {
      console.error('ÊåâË™ûË®ÄÁç≤ÂèñÊ≠∑Âè≤Ë®òÈåÑÂ§±Êïó:', error);
      return [];
    }
  }

  // Áç≤ÂèñÊúÄËøëÁöÑÊü•Ë©¢Ë®òÈåÑ
  async getRecentHistory(limit = 50) {
    try {
      const history = await this.getHistory();
      if (!Array.isArray(history)) {
        console.error('‚ö†Ô∏è getRecentHistory: history is not an array');
        return [];
      }
      return history.slice(0, limit);
    } catch (error) {
      console.error('Áç≤ÂèñÊúÄËøëÊ≠∑Âè≤Ë®òÈåÑÂ§±Êïó:', error);
      return [];
    }
  }

  // Áç≤ÂèñÊúÄÂ∏∏Êü•Ë©¢ÁöÑË©ûÂΩô
  async getMostQueried(limit = 10) {
    try {
      const history = await this.getHistory();
      if (!Array.isArray(history)) {
        console.error('‚ö†Ô∏è getMostQueried: history is not an array');
        return [];
      }
      const sortedByCount = history.sort((a, b) => b.queryCount - a.queryCount);
      return sortedByCount.slice(0, limit);
    } catch (error) {
      console.error('Áç≤ÂèñÊúÄÂ∏∏Êü•Ë©¢Ë©ûÂΩôÂ§±Êïó:', error);
      return [];
    }
  }

  // Âà™Èô§ÁâπÂÆöË®òÈåÑ
  async deleteRecord(id) {
    try {
      const history = await this.getHistory();
      if (!Array.isArray(history)) {
        console.error('‚ö†Ô∏è deleteRecord: history is not an array');
        return false;
      }
      const filteredHistory = history.filter(record => record.id !== id);
      await this.saveHistory(filteredHistory);
      return true;
    } catch (error) {
      console.error('Âà™Èô§Ê≠∑Âè≤Ë®òÈåÑÂ§±Êïó:', error);
      return false;
    }
  }

  // Ê∏ÖÁ©∫Ê≠∑Âè≤Ë®òÈåÑ
  async clearHistory() {
    try {
      await chrome.storage.local.remove([this.STORAGE_KEY]);
      console.log('üóëÔ∏è History cleared successfully');
      return true;
    } catch (error) {
      console.error('Ê∏ÖÁ©∫Ê≠∑Âè≤Ë®òÈåÑÂ§±Êïó:', error);
      return false;
    }
  }

  // Ë®∫Êñ∑Ê≠∑Âè≤Ë®òÈåÑÊï∏ÊìöÁãÄÊÖã
  async diagnoseHistory() {
    try {
      console.log('üîç Starting history diagnosis...');
      
      const result = await chrome.storage.local.get([this.STORAGE_KEY]);
      const rawHistory = result[this.STORAGE_KEY];
      
      const diagnosis = {
        exists: rawHistory !== undefined,
        type: typeof rawHistory,
        isArray: Array.isArray(rawHistory),
        isEmpty: !rawHistory,
        keys: [],
        sampleData: null,
        corruptionType: 'none'
      };
      
      if (rawHistory) {
        if (typeof rawHistory === 'object') {
          diagnosis.keys = Object.keys(rawHistory);
          diagnosis.sampleData = JSON.stringify(rawHistory).substring(0, 300);
          
          if (!Array.isArray(rawHistory)) {
            // Determine corruption type
            const keys = Object.keys(rawHistory);
            const hasNumericKeys = keys.some(key => /^\d+$/.test(key));
            const hasNestedArrays = Object.values(rawHistory).some(value => Array.isArray(value));
            
            if (hasNumericKeys) {
              diagnosis.corruptionType = 'array-like-object';
            } else if (hasNestedArrays) {
              diagnosis.corruptionType = 'nested-arrays';
            } else {
              diagnosis.corruptionType = 'unknown-object';
            }
          }
        }
      }
      
      console.log('üìä History diagnosis result:', diagnosis);
      return diagnosis;
    } catch (error) {
      console.error('‚ùå History diagnosis failed:', error);
      return { error: error.message };
    }
  }

  // ‰øÆÂæ©ÊêçÂ£ûÁöÑÊ≠∑Âè≤Ë®òÈåÑÊï∏Êìö
  async repairHistory() {
    try {
      console.log('üîß Starting history repair...');
      
      // ÂÖàË®∫Êñ∑ÂïèÈ°å
      const diagnosis = await this.diagnoseHistory();
      console.log('üîç Diagnosis:', diagnosis);
      
      // Âº∑Âà∂ÈáçÊñ∞Âä†ËºâÂíåÈ©óË≠âÊ≠∑Âè≤Ë®òÈåÑ
      const history = await this.getHistory();
      
      if (!Array.isArray(history)) {
        console.log('üîÑ History was not an array, clearing...');
        await this.clearHistory();
        return { 
          repaired: true, 
          recordsRecovered: 0, 
          diagnosis,
          action: 'cleared-corrupted-data'
        };
      }
      
      const originalLength = history.length;
      
      // ÈáçÊñ∞‰øùÂ≠òÊúÉËß∏ÁôºÈ©óË≠âÂíåÊ∏ÖÁêÜ
      await this.saveHistory(history);
      
      const newHistory = await this.getHistory();
      const finalLength = newHistory.length;
      
      console.log(`‚úÖ History repair completed: ${originalLength} ‚Üí ${finalLength} records`);
      
      return {
        repaired: true,
        originalRecords: originalLength,
        recordsRecovered: finalLength,
        recordsRemoved: originalLength - finalLength,
        diagnosis,
        action: 'cleaned-and-validated'
      };
    } catch (error) {
      console.error('‚ùå History repair failed:', error);
      return { repaired: false, error: error.message };
    }
  }

  // Áç≤ÂèñÊ≠∑Âè≤Áµ±Ë®à
  async getHistoryStats() {
    try {
      const history = await this.getHistory();
      if (!Array.isArray(history)) {
        console.error('‚ö†Ô∏è getHistoryStats: history is not an array');
        return null;
      }
      
      const stats = {
        totalQueries: history.length,
        totalQueryCount: history.reduce((sum, record) => sum + record.queryCount, 0),
        languageStats: {},
        averageQueriesPerDay: 0,
        mostActiveDay: null
      };

      // Ë™ûË®ÄÁµ±Ë®à
      history.forEach(record => {
        if (!stats.languageStats[record.language]) {
          stats.languageStats[record.language] = {
            count: 0,
            queryCount: 0
          };
        }
        stats.languageStats[record.language].count++;
        stats.languageStats[record.language].queryCount += record.queryCount;
      });

      // ÊØèÊó•Êü•Ë©¢Áµ±Ë®à
      if (history.length > 0) {
        const oldestRecord = history[history.length - 1];
        const daysSinceFirst = Math.ceil((Date.now() - oldestRecord.timestamp) / (1000 * 60 * 60 * 24));
        stats.averageQueriesPerDay = Math.round(stats.totalQueryCount / Math.max(daysSinceFirst, 1));
      }

      return stats;
    } catch (error) {
      console.error('Áç≤ÂèñÊ≠∑Âè≤Áµ±Ë®àÂ§±Êïó:', error);
      return null;
    }
  }

  // ÁîüÊàêÂîØ‰∏ÄID
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }

  // Ê†ºÂºèÂåñÊôÇÈñìÊà≥
  formatTimestamp(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now - date;
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) {
      return `‰ªäÂ§© ${date.toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit' })}`;
    } else if (diffDays === 1) {
      return `Êò®Â§© ${date.toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit' })}`;
    } else if (diffDays < 7) {
      return `${diffDays} Â§©Ââç`;
    } else {
      return date.toLocaleDateString('zh-TW', { month: 'short', day: 'numeric' });
    }
  }
}

// ÂåØÂá∫ HistoryManager
if (typeof module !== 'undefined' && module.exports) {
  module.exports = HistoryManager;
} else if (typeof self !== 'undefined') {
  self.HistoryManager = HistoryManager;
} else {
  this.HistoryManager = HistoryManager;
}